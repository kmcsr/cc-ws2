<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>CC websocket daemon webpoint</title>
		<style>
			@keyframes flash {
				0%   { opacity: 0; }
				50%  { opacity: 1; }
				100% { opacity: 0; }
			}

			* {
				box-sizing: border-box;
			}

			#host-list {
				display: inline-block;
			}

			.device {
				cursor: pointer;
				border-bottom: #0003 1px soild;
				transition: all 0.5s ease;
			}
			.device:hover {
				background: lightgray;
				padding: 0.1rem 0;
			}
			.device.selected {
				background: gray;
				color: #eee;
			}

			#term-nav {
				display: flex;
				flex-direction: row;
				align-items: center;
				height: 2rem;
				font-family: monospace;
				background: lightgray;
			}
			#term-nav button {
				display: inline-block;
				background: transparent;
				height: 100%;
				border: none;
				border-right: #eee 1px solid;
				color: #fff;
				cursor: pointer;
				user-select: none;
			}
			#term-nav button.selected {
				background: #000d;
			}

			#term-box {
				display: inline-flex;
				flex-direction: column;
				font-family: monospace;
				user-select: none;
				background: lightgray;
				border: 0.5rem ridge #ffff99;
				padding: 1px;
			}
			#term-box div {
				display: inline-flex;
				flex-direction: row;
			}
			#term-cursor, #term-box span {
				width: 10px;
				height: 15px;
				padding: 1px;
				font-size: 14px;
				line-height: 12px;
			}

			#term-cursor {
				font-family: monospace;
				position: absolute;
				user-select: none;
				animation: flash 1s infinite;
			}
		</style>

		<script delay>
			/**** utils ****/
			function sleep(ms){
				return new Promise((resolve) => {
					setTimeout(() => resolve(), ms)
				})
			}
			function toHexColor(num){
				let s = Number.parseInt(num).toString(16)
				if(s === 'NaN'){
					return null
				}
				if(s.length > 6){
					throw 'Number is too big'
				}
				s = '#' + '0'.repeat(6 - s.length) + s
				return s
			}
			function toCCMouseBtn(btn){
				switch(btn){
				case 0: return 1 // left button
				case 1: return 3 // middle button
				case 2: return 2 // right button
				default: return null
				}
			}
			function toCCKeyId(code){
				if(!code){
					return null
				}
				let lcode = code.toLowerCase()
				if(lcode.length === 1 && 'a' <= lcode && lcode <= 'z'){
					return lcode
				}
				if(lcode.startsWith('key') && lcode.length === 4){
					let rcode = lcode.substr(3, 1)
					if('a' <= rcode && rcode <= 'z'){
						return rcode
					}
				}
				if(lcode.startsWith('numpad')){
					return 'numPad' + code.substr(6)
				}
				if(lcode.startsWith('arrow')){
					return lcode.substr(5)
				}
				if(lcode.startsWith('f')){ // function keys F<number>
					let n = Number.parseInt(lcode.substr(1))
					if('f' + n === lcode){
						return lcode
					}
				}
				switch(lcode){
				case 'pause':
				case 'home':
				case 'end':
				case 'insert':
				case 'delete':
				case 'semicolon':
				case 'comma':
				case 'minus':
				case 'period':
				case 'slash':
				case 'backspace':
				case 'tab':
				case 'enter':
				case 'backslash':
				case 'space':
					return lcode
				case 'equal': return 'equals'
				case 'quote': return 'apostrophe'
				case 'pageup': return 'pageUp'
				case 'pagedown': return 'pageDown'
				case 'printscreen': return 'printScreen'
				case 'shiftleft': return 'leftShift'
				case 'shiftright': return 'rightShift'
				case 'ctrlleft': return 'leftCtrl'
				case 'ctrlright': return 'rightCtrl'
				case 'altleft': return 'leftAlt'
				case 'altright': return 'rightAlt'
				case 'capslock': return 'capsLock'
				case 'numlock': return 'numLock'
				case 'scrolllock': return 'scrollLock'
				case 'backquote': return 'grave'
				case 'digit0': return 'zero'
				case 'digit1': return 'one'
				case 'digit2': return 'two'
				case 'digit3': return 'three'
				case 'digit4': return 'four'
				case 'digit5': return 'five'
				case 'digit6': return 'six'
				case 'digit7': return 'seven'
				case 'digit8': return 'eight'
				case 'digit9': return 'nine'
				case 'bracketleft': return 'leftBracket'
				case 'bracketright': return 'rightBracket'
				case 'contextmenu': return 'menu'
				}
				return code.substr(0, 1).toLowerCase() + code
			}

			var wsMessageListeners = {}
			var terminals = {} // hostid: connid: termid: term
			async function connectWs(token){
				const ws = new WebSocket(`${window.location.origin.replace('http', 'ws')}/wscli?authTk=${encodeURIComponent(token)}`)
				await new Promise((resolve, reject) => {
					ws.addEventListener('open', (event) => {
						resolve(event)
						ws.removeEventListener('error', reject)
					})
					ws.addEventListener('error', reject)
				})
				var askIncreasement = 0
				var asking = {}
				ws.ask = function(type, data){
					let id = askIncreasement
					while(asking[++id]);
					asking[id] = true
					askIncreasement = id
					return new Promise((resolve) => {
						asking[id] = resolve
						ws.send(JSON.stringify({
							type: type,
							id: id,
							data: data,
						}))
					})
				}
				ws.fireTermEvent = function(host, conn, term, event, ...args){
					ws.send(JSON.stringify({
						type: 'fire_event',
						host: host,
						conn: conn,
						term: term,
						event: event,
						args: args,
					}))
				}
				ws.addEventListener('message', (event) => {
					const data = JSON.parse(event.data)
					switch(data.type){
					case 'reply':
						let resolve = asking[data.id]
						resolve(data.data)
						break
					default:
						let handler = wsMessageListeners[data.type]
						if(handler){
							try{
								handler(data)
							}catch(e){
								console.error('Error when handling message:', e)
							}
						}else{
							// console.debug('not handled msg:', data)
						}
					}
				})
				ws.addEventListener('error', (event) => {
					console.log('websocket on error:', event)
				})
				return ws
			}
			window.addEventListener('DOMContentLoaded', () => {
				var ws = null
				const connectStatus = document.getElementById('connect-status')
				const tokenElement = document.getElementById('connect-token')
				const connectButton = document.getElementById('connect-button')
				const hostList = document.getElementById('host-list')
				var connecting = false
				async function onConnect(){
					if(connecting){
						return
					}
					connecting = true
					const token = tokenElement.value
					if(!token){
						connecting = false
						alert('Please input the secret token') // TODO: better alert
						tokenElement.focus()
						return
					}
					tokenElement.value = ''
					try{
						tokenElement.disabled = true
						connectButton.disabled = true
						connectStatus.innerText = 'Connecting...'
						connectStatus.style.color = 'orange'

						if(ws){ // reconnect
							connectStatus.innerText = 'Reconnecting...'
							console.log('reconnecting...')
							ws.close()
						}
						connectButton.value = 'connecting...'
						ws = await connectWs(token)
						ws.addEventListener('close', (event) => {
							connectButton.value = 'Connect'
							connectStatus.innerText = `Closed (${event.code})`
							connectStatus.style.color = 'blue'
						})
						connectButton.value = 'Reconnect'
					}catch(e){
						connectStatus.innerText = 'Error'
						connectStatus.style.color = 'red'
						connectButton.value = 'Connect'
						throw e
					}finally{
						tokenElement.disabled = false
						connectButton.disabled = false
						connecting = false
					}
					connectStatus.innerText = 'Connected'
					connectStatus.style.color = 'green'
					refreshDatas()
				}
				tokenElement.addEventListener('keydown', (event) => {
					if(event.code === 13 || event.key.toLowerCase() === 'enter'){
						onConnect()
					}
				})
				connectButton.addEventListener('click', onConnect)

				async function refreshDatas(){
					let hosts = (await ws.ask('list_hosts')) || []
					let children = []
					for(let host of hosts){
						let data = await ws.ask('get_host', host.id)
						if(data.status !== 'ok'){
							console.error('Cannot get host', data.error)
							return
						}
						let conns = data.res.conns || []
						let child = document.createElement('li')
						{
							let idE = document.createElement('b')
							idE.innerText = 'ID: ' + host.id
							child.appendChild(idE)
						}
						{
							let connsE = document.createElement('div')
							{
								let e = document.createElement('div')
								e.innerText = 'Total Connections: ' + conns.length
								connsE.appendChild(e)
								let turtles = conns.filter(c => c.device === 'turtle')
								let pockets = conns.filter(c => c.device === 'pocket')
								let computers = conns.filter(c => c.device === 'computer')
								e = document.createElement('div')
								e.innerText = 'Turtles: ' + turtles.length
								connsE.appendChild(e)
								let ul = document.createElement('ul')
								for(let c of turtles){
									let e = createDeviceElement('li', host.id, c.id)
									ul.appendChild(e)
								}
								connsE.appendChild(ul)
								e = document.createElement('div')
								e.innerText = 'Pockets: ' + pockets.length
								connsE.appendChild(e)
								ul = document.createElement('ul')
								for(let c of pockets){
									let e = createDeviceElement('li', host.id, c.id)
									ul.appendChild(e)
								}
								connsE.appendChild(ul)
								e = document.createElement('div')
								e.innerText = 'Computers: ' + computers.length
								connsE.appendChild(e)
								ul = document.createElement('ul')
								for(let c of computers){
									let e = createDeviceElement('li', host.id, c.id)
									ul.appendChild(e)
								}
								connsE.appendChild(ul)
							}
							child.appendChild(connsE)
						}
						children.push(child)
					}
					hostList.replaceChildren(...children)
				}
				wsMessageListeners['device_join'] = () => { refreshDatas() }
				wsMessageListeners['device_leave'] = () => { refreshDatas() }
				var selectingEle = null
				var selectingTerm = null
				function createDeviceElement(tag, host, id){
					let ele = document.createElement(tag)
					ele.classList.add('device')
					if(selectingEle && selectingEle.host === host && selectingEle.conn === id){
						ele.classList.add('selected')
					}
					ele.onclick = () => { onClickDevice(ele, host, id) }
					ele.innerText = id
					return ele
				}

				const termBlock = document.getElementById('term-block')
				const termNav = document.getElementById('term-nav')
				const termBox = document.getElementById('term-box')
				const termCursor = document.getElementById('term-cursor')
				async function onClickDevice(ele, host, id){
					if(selectingEle && selectingEle.host === host && selectingEle.conn === id){
						return
					}
					if(selectingEle && selectingEle.ele){
						selectingEle.ele.classList.remove('selected')
					}
					selectingEle = {
						ele: ele,
						host: host,
						conn: id,
					}
					selectingTerm = null
					ele.classList.add('selected')
					termBlock.style.display = 'block'
					const terms = await ws.ask('list_terms', {
						host: host,
						conn: id,
					})
					if(terms.status !== 'ok') {
						console.error('Cannot get term list:', terms.error)
						return
					}
					var termEles = []
					if(terms.res){
						for(let t of terms.res){
							let tid = t.id
							let e = document.createElement('button')
							e.innerText = t.title
							e.addEventListener('click', () => { onClickTerm(e, host, id, tid) })
							termEles.push(e)
						}
					}
					termNav.replaceChildren(...termEles)
				}

				var termData = null
				function setTermCursorPos(x, y){
					termData.cursorX = x
					termData.cursorY = y

					if(x < 0 || x >= termData.width ||
						y < 0 || y >= termData.height ||
						!termData.cursorBlink){
						termCursor.style.display = 'none'
						return
					}
					let e = termBox.children[y].children[x]
					let parentRect = termBox.getBoundingClientRect()
					let rect = e.getBoundingClientRect()
					termCursor.style.display = 'block'
					termCursor.style.color = toHexColor(termData.palette[termData.textColor])
					termCursor.style.top = rect.y - parentRect.y + 'px'
					termCursor.style.left = rect.x - parentRect.x + 'px'
				}
				function redrawTerm(termData){
					var termEles = []
					for(let y = 0; y < termData.height; y++){
						const lineE = document.createElement('div')
						termEles.push(lineE)
						const line = termData.lines[y]
						for(let x = 0; x < termData.width; x++){
							const charE = document.createElement('span')
							charE.innerText = line.text[x]
							charE.style.color =
								toHexColor(termData.palette[line.color[x]]) || toHexColor(termData.palette[termData.textColor])
							charE.style.backgroundColor =
								toHexColor(termData.palette[line.background[x]]) || toHexColor(termData.palette[termData.backgroundColor])
							lineE.appendChild(charE)
						}
					}
					termBox.replaceChildren(...termEles)
					setTermCursorPos(termData.cursorX, termData.cursorY)
				}
				wsMessageListeners['term.oper'] = (event) => {
					event = event.data
					if(termData){
						if(event.host === termData.host && event.conn === termData.conn){
							const args = event.args
							if(args[0] === termData.term){
								switch(args[1]){
								case 'write': {
									let [text] = args[2]
									if(termData.cursorY < 0 || termData.cursorY >= termData.height || termData.cursorX >= termData.width){
										return
									}
									if(termData.cursorX < 0){
										text = text.substr(-termData.cursorX)
										termData.cursorX = 0
									}
									const line = termData.lines[termData.cursorY]
									const lineE = termBox.children[termData.cursorY]
									let l = termData.width - termData.cursorX
									if(text.length < l){
										l = text.length
									}else{
										text = text.substr(0, l)
									}
									line.text = line.text.substring(0, termData.cursorX) + text + line.text.substr(termData.cursorX + l)
									for(let i = 0; i < l; i++){
										let j = termData.cursorX + i
										const charE = lineE.children[j]
										charE.innerText = text[i]
										charE.style.color = toHexColor(termData.palette[line.color[j] = termData.textColor])
										charE.style.backgroundColor =
											toHexColor(termData.palette[line.background[j] = termData.backgroundColor])
									}
									setTermCursorPos(termData.cursorX + l, termData.cursorY)
									break
								}
								case 'blit': {
									let [text, color, bgColor] = args[2]
									if(termData.cursorY < 0 || termData.cursorY >= termData.height || termData.cursorX >= termData.width){
										return
									}
									if(termData.cursorX < 0){
										text = text.substr(-termData.cursorX)
										color = color.slice(-termData.cursorX)
										bgColor = bgColor.slice(-termData.cursorX)
										termData.cursorX = 0
									}
									const line = termData.lines[termData.cursorY]
									const lineE = termBox.children[termData.cursorY]
									let l = termData.width - termData.cursorX
									if(text.length < l){
										l = text.length
									}else{
										text = text.substr(0, l)
									}
									line.text = line.text.substring(0, termData.cursorX) + text + line.text.substr(termData.cursorX + l)
									for(let i = 0; i < l; i++){
										let j = termData.cursorX + i
										const charE = lineE.children[j]
										charE.innerText = text[i]
										charE.style.color = toHexColor(termData.palette[line.color[j] = color[i]])
										charE.style.backgroundColor =
											toHexColor(termData.palette[line.background[j] = bgColor[i]])
									}
									setTermCursorPos(termData.cursorX + l, termData.cursorY)
									break
								}
								case 'setCursorPos': {
									let [x, y] = args[2]
									setTermCursorPos(x - 1, y - 1)
									break
								}
								case 'setCursorBlink': {
									let [blink] = args[2]
									termCursor.style.display =
										(termData.cursorBlink = blink) ?'block' :'none'
									break
								}
								case 'setTextColour':
								case 'setTextColor': {
									let [c] = args[2]
									termData.textColor = c
									break
								}
								case 'setBackgroundColour':
								case 'setBackgroundColor': {
									let [c] = args[2]
									termData.backgroundColor = c
									break
								}
								case 'scroll': {
									let [offset] = args[2]
									if(!offset){
										break
									}
									let down = offset < 0
									if(down){
										offset = -offset
									}
									if(offset < termData.height){
										const emptyLineE = document.createElement('div')
										const emptyLine = {
											text: ' '.repeat(termData.width),
											color: new Array(termData.width).fill(termData.textColor),
											background: new Array(termData.width).fill(termData.backgroundColor),
										}
										for(let x = 0; x < termData.width; x++){
											const charE = document.createElement('span')
											charE.innerText = ' '
											charE.style.color = toHexColor(termData.palette[termData.textColor])
											charE.style.backgroundColor = toHexColor(termData.palette[termData.backgroundColor])
											emptyLineE.appendChild(charE)
										}
										if(down){
											termData.lines.pop()
											termData.lines.unshift(emptyLine)
											termBox.removeChild(termBox.lastElementChild)
											termBox.insertBefore(emptyLineE, termBox.firstElementChild)
										}else{
											termData.lines.shift()
											termData.lines.push(emptyLine)
											termBox.removeChild(termBox.firstElementChild)
											termBox.appendChild(emptyLineE)
										}
										break
									}
								}
								case 'clear': {
									for(let y = 0; y < termData.height; y++){
										const lineE = termBox.children[y]
										const line = termData.lines[y]
										line.text = ' '.repeat(termData.width)
										for(let x = 0; x < termData.width; x++){
											const charE = lineE.children[x]
											charE.innerText = ' '
											charE.style.color = toHexColor(termData.palette[line.color[x] = termData.textColor])
											charE.style.backgroundColor =
												toHexColor(termData.palette[line.background[x] = termData.backgroundColor])
										}
									}
									break
								}
								case 'clearLine': {
									let [y] = args[2]
									if(y < 0 || y >= termData.height){
										break
									}
									const lineE = termBox.children[y]
									const line = termData.lines[y]
									line.text = ' '.repeat(termData.width)
									for(let x = 0; x < termData.width; x++){
										const charE = lineE.children[x]
										charE.innerText = ' '
										charE.style.color = toHexColor(termData.palette[line.color[x] = termData.textColor])
										charE.style.backgroundColor =
											toHexColor(termData.palette[line.background[x] = termData.backgroundColor])
									}
									break
								}
								default:
									// do nothing
								}
							}
						}
					}
				}
				function onClickTerm(ele, host, conn, tid){
					if(!selectingTerm || selectingTerm.host !== host || selectingTerm.conn !== conn || selectingTerm.term !== tid){
						if(selectingTerm && selectingTerm.ele){
							selectingTerm.ele.classList.remove('selected')
						}
						selectingTerm = {
							ele: ele,
							host: host,
							conn: conn,
							term: tid,
						}
						ele.classList.add('selected')
					}
					updateTerm()
				}
				async function updateTerm(){
					if(!selectingTerm){
						return
					}
					const term = await ws.ask('get_term', {
						host: selectingTerm.host,
						conn: selectingTerm.conn,
						term: selectingTerm.term,
					})
					if(term.status !== 'ok') {
						console.error('Cannot get term data:', term.error)
						return
					}
					termData = term.res
					termData.host = selectingTerm.host
					termData.conn = selectingTerm.conn
					termData.term = selectingTerm.term

					redrawTerm(termData)
					termBox.focus()
				}
				var focusingTerm = false
				termBox.addEventListener('focus', () => {
					focusingTerm = true
				})
				termBox.addEventListener('blur', () => {
					focusingTerm = false
				})
				function onTermEvent(event){
					if(!focusingTerm){
						return
					}
					switch(event.type){
					case 'keydown': {
						let keyCode = toCCKeyId(event.code)
						if(event.metaKey){
							return
						}
						let press = event.repeat
						ws.fireTermEvent(termData.host, termData.conn, termData.term, 'key', keyCode, press)
						if(event.key.length === 1){ // most likely inputed a char
							ws.fireTermEvent(termData.host, termData.conn, termData.term, 'char', event.key)
						}
						break
					}
					case 'keyup': {
						let keyCode = toCCKeyId(event.code)
						ws.fireTermEvent(termData.host, termData.conn, termData.term, 'key_up', keyCode)
						break
					}
					case 'mousedown': {
						let target = event.target
						let x = Array.from(target.parentElement.children).indexOf(target) + 1
						let y = Array.from(termBox.children).indexOf(target.parentElement) + 1
						let btn = toCCMouseBtn(event.button)
						if(btn !== null){
							ws.fireTermEvent(termData.host, termData.conn, termData.term, 'mouse_click', btn, x, y)
						}
						break
					}
					case 'mouseup': {
						let target = event.target
						let x = Array.from(target.parentElement.children).indexOf(target) + 1
						let y = Array.from(termBox.children).indexOf(target.parentElement) + 1
						let btn = toCCMouseBtn(event.button)
						if(btn !== null){
							ws.fireTermEvent(termData.host, termData.conn, termData.term, 'mouse_click', btn, x, y)
						}
						break
					}
					case 'mousewheel': {
						let target = event.target
						let x = Array.from(target.parentElement.children).indexOf(target) + 1
						let y = Array.from(termBox.children).indexOf(target.parentElement) + 1
						if(event.deltaX){
							ws.fireTermEvent(termData.host, termData.conn, termData.term, 'mouse_scroll', event.deltaX < 0 ?-1 :1, x, y)
						}
						break
					}
					default:
						console.debug('on event:', event)
					}
					event.preventDefault()
				}
				termBox.addEventListener('keydown', onTermEvent)
				termBox.addEventListener('keyup', onTermEvent)
				termBox.addEventListener('mousedown', onTermEvent)
				termBox.addEventListener('mouseup', onTermEvent)
				termBox.addEventListener('mousewheel', onTermEvent)
				termCursor.addEventListener('mousedown', (event) => {
					let x = termData.cursorX + 1, y = termData.cursorY + 1
					let btn = toCCMouseBtn(event.button)
					if(btn !== null){
						ws.fireTermEvent(termData.host, termData.conn, termData.term, 'mouse_click', btn, x, y)
					}
					event.preventDefault()
				})
				termCursor.addEventListener('mouseup', (event) => {
					let x = termData.cursorX + 1, y = termData.cursorY + 1
					let btn = toCCMouseBtn(event.button)
					if(btn !== null){
						ws.fireTermEvent(termData.host, termData.conn, termData.term, 'mouse_up', btn, x, y)
					}
					event.preventDefault()
				})
				termCursor.addEventListener('mousewheel', (event) => {
					let x = termData.cursorX + 1, y = termData.cursorY + 1
					if(event.deltaX){
						ws.fireTermEvent(termData.host, termData.conn, termData.term, 'mouse_scroll', event.deltaX < 0 ?-1 :1, x, y)
					}
					event.preventDefault()
				})
				document.addEventListener('contextmenu', (event) => {
					if(focusingTerm){
						event.preventDefault()
					}
				});
			})
		</script>
	</head>
	<body>
		<main>
			<h1>CC websocket daemon webpoint</h1>
			<div>
				Status: <b><span id="connect-status">Idle</span></b>
			</div>
			<div>
				<label of="connect-token">Connect Token:</label>
				<input id="connect-token" type="password"/>
				<input id="connect-button" type="button" value="Connect"/>
			</div>
			<div>
				<ul id="host-list">
				</ul>
			</div>
			<hr/>
			<div id="term-block" style="display: none;">
				<h3>Term</h3>
				<div>
					<nav id="term-nav">
					</nav>
				</div>
				<div style="position: absolute;">
					<div id="term-box" tabindex="0">
					</div>
					<div id="term-cursor" style="display: none">_</div>
				</div>
			</div>
		</main>
	</body>
</html>